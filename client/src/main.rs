extern crate e2d2;

mod wireformat;

use std::sync::Arc;
use std::fmt::Display;
use std::str::FromStr;
use std::mem::size_of;
use std::net::Ipv4Addr;

use e2d2::scheduler::*;
use e2d2::scheduler::NetBricksContext as NetbricksContext;
use e2d2::interface::*;
use e2d2::headers::*;
use e2d2::config::{ NetbricksConfiguration, PortConfiguration };
use e2d2::common::EmptyMetadata;

use self::wireformat::GetRequest;

struct RequestGenerator<T>
where
    T: PacketTx + PacketRx + Display + Clone + 'static,
{
    net_port: T,

    // The RPC header on each packet generated by the request generator.
    req_rpc_header: GetRequest,

    // The UDP header on each packet generated by the request generator.
    req_udp_header: UdpHeader,

    // The IP header on each packet generated by the request generator.
    // Currently using IPv4.
    req_ip_header: IpHeader,

    // The MAC header on each packet generated by the request generator.
    req_mac_header: MacHeader,
}

impl<T> RequestGenerator<T>
where
    T: PacketTx + PacketRx + Display + Clone + 'static,
{
    /// This function returns an instance of RequestGenerator. The RPC, UDP, IP,
    /// and MAC headers on packets generated by this instance are pre-computed
    /// in this method.
    fn new(port: T) -> RequestGenerator<T> {
        // Create a common rpc header.
        let rpc_tenant: u32 = 1;
        let rpc_table_id: u64 = 1;
        let rpc_key_length: u16 = 30;

        let rpc_header: GetRequest = GetRequest::new(rpc_tenant, rpc_table_id,
                                                     rpc_key_length);

        let rpc_header_length: u16 = size_of::<GetRequest>() as u16;

        // Create a common udp header.
        let udp_src_port: u16 = 0;
        let udp_dst_port: u16 = 0;
        let udp_length: u16 = 8 + rpc_header_length + rpc_key_length;
        let udp_checksum: u16 = 0;

        let mut udp_header: UdpHeader = UdpHeader::new();
        udp_header.set_src_port(udp_src_port);
        udp_header.set_dst_port(udp_dst_port);
        udp_header.set_length(udp_length);
        udp_header.set_checksum(udp_checksum);

        // Create a common ip header.
        let ip_src_addr: u32 =
                    u32::from(Ipv4Addr::from_str("192.168.0.1")
                                .expect("Failed to create source IP."));
        let ip_dst_addr: u32 =
                    u32::from(Ipv4Addr::from_str("192.168.0.2")
                                .expect("Failed to create destination IP."));
        let ip_ttl: u8 = 128;
        let ip_version: u8 = 4;
        let ip_ihl: u8 = 5;
        let ip_length: u16 = 20 + udp_length;

        let mut ip_header: IpHeader = IpHeader::new();
        ip_header.set_src(ip_src_addr);
        ip_header.set_dst(ip_dst_addr);
        ip_header.set_ttl(ip_ttl);
        ip_header.set_version(ip_version);
        ip_header.set_ihl(ip_ihl);
        ip_header.set_length(ip_length);

        // Create a common mac header.
        let mac_src_addr: MacAddress =
                    MacAddress::new(0x3c, 0xfd, 0xfe, 0x05, 0x9b, 0x60);
        let mac_dst_addr: MacAddress =
                    MacAddress::new(0x3c, 0xfd, 0xfe, 0x05, 0xcf, 0x00);
        let mac_etype: u16 = 0x0800;

        let mut mac_header: MacHeader = MacHeader::new();
        mac_header.src = mac_src_addr;
        mac_header.dst = mac_dst_addr;
        mac_header.set_etype(mac_etype);

        // Return an instance of RequestGenerator.
        RequestGenerator {
            net_port: port.clone(),
            req_rpc_header: rpc_header,
            req_udp_header: udp_header,
            req_ip_header: ip_header,
            req_mac_header: mac_header,
        }
    }

    #[inline]
    fn push_rpc_header(&self,
                       request: Packet<UdpHeader, EmptyMetadata>) ->
        Packet<GetRequest, EmptyMetadata>
    {
        request.push_header(&self.req_rpc_header)
                .expect("Failed to push RPC header into request!")
    }

    #[inline]
    fn push_udp_header(&self,
                       request: Packet<IpHeader, EmptyMetadata>) ->
        Packet<UdpHeader, EmptyMetadata>
    {
        request.push_header(&self.req_udp_header)
                .expect("Failed to push UDP header into request!")
    }

    #[inline]
    fn push_ip_header(&self,
                      request: Packet<MacHeader, EmptyMetadata>) ->
        Packet<IpHeader, EmptyMetadata>
    {
        request.push_header(&self.req_ip_header)
                .expect("Failed to push IP header into request!")
    }

    #[inline]
    fn push_mac_header(&self,
                       request: Packet<NullHeader, EmptyMetadata>) ->
        Packet<MacHeader, EmptyMetadata>
    {
        request.push_header(&self.req_mac_header)
                .expect("Failed to push MAC header into request!")
    }

    #[inline]
    fn generate_request(&self) {
        // Allocate a packet.
        let request: Packet<NullHeader, EmptyMetadata> =
                    new_packet()
                        .expect("Failed to allocate packet for request!");

        // Populate headers into the packet.
        let request = self.push_mac_header(request);
        let request = self.push_ip_header(request);
        let request = self.push_udp_header(request);
        let mut request = self.push_rpc_header(request);

        let key: [u8; 30] = [1; 30];
        request.add_to_payload_tail(30, &key)
                .expect("Failed to write key into get() request!");

        unsafe {
            let mut pkts = [ request.get_mbuf() ];

            match self.net_port.send(&mut pkts) {
                Ok(sent) => {
                    if sent < pkts.len() as u32 {
                        println!("WARNING: Failed to send all packets!");
                    }
                }

                Err(ref err) => {
                    println!("Error on packet send: {}", err);
                    std::process::exit(1);
                }
            }

            let rpc_header_offset: usize = self.req_mac_header.offset() +
                                           self.req_ip_header.offset() +
                                           self.req_udp_header.offset();
            packet_from_mbuf_no_increment::<GetRequest>(pkts[0],
                                                        rpc_header_offset)
                .free_packet();
        }
    }
}

impl<T> Executable for RequestGenerator<T>
where
    T: PacketTx + PacketRx + Display + Clone + 'static,
{
    fn execute(&mut self) {
        self.generate_request();
    }

    fn dependencies(&mut self) -> Vec<usize> {
        vec![]
    }
}

/// This function adds a request generator (RequestGenerator) to a Netbricks
/// pipeline. This function is passed in as a closure to Netbricks, and gets
/// run once on each Netbricks scheduler during setup.
fn setup_client<T, S>(ports: Vec<T>, scheduler: &mut S)
where
    T: PacketTx + PacketRx + Display + Clone + 'static,
    S: Scheduler + Sized,
{
    if ports.len() != 1 {
        println!("ERROR: Client should be configured with exactly 1 port!");
        std::process::exit(1);
    }

    let client: RequestGenerator<T> = RequestGenerator::new(ports[0].clone());

    // Add the request generator to a netbricks pipeline.
    match scheduler.add_task(client) {
        Ok(_) => {
            println!("Successfully added client to a Netbricks pipeline.");
        }

        Err(ref err) => {
            println!("Error while adding to Netbricks pipeline {}", err);
            std::process::exit(1);
        }
    }
}

/// Returns a struct of type NetbricksConfiguration which can be used to
/// initialize Netbricks with a default set of parameters.
///
/// If used to initialize Netbricks, this struct will run the parent client
/// thread on core 0, and one scheduler on core 1. Packet buffers will be
/// allocated from a 2 GB memory pool, with 64 MB cached at core 1. DPDK will
/// be initialized as a primary process without any additional arguments. A
/// single network interface/port with 1 transmit queue, 1 receive queue, 256
/// receive descriptors, and 256 transmit descriptors will be made available to
/// Netbricks. Loopback, hardware transmit segementation offload, and hardware
/// checksum offload will be disabled on this port.
fn get_default_netbricks_config() -> NetbricksConfiguration {
    // General arguments supplied to netbricks.
    let net_config_name = String::from("sandstorm_client_net");
    let dpdk_secondary: bool = false;
    let net_primary_core: i32 = 0;
    let net_cores: Vec<i32> = vec![1];
    let net_strict_cores: bool = true;
    let net_pool_size: u32 = 2048 - 1;
    let net_cache_size: u32 = 64;
    let net_dpdk_args: Option<String> = None;

    // Port configuration. Required to configure the physical network interface.
    let net_port_name = String::from("0000:06:00.0");
    let net_port_rx_queues: Vec<i32> = net_cores.clone();
    let net_port_tx_queues: Vec<i32> = net_cores.clone();
    let net_port_rxd: i32 = 256;
    let net_port_txd: i32 = 256;
    let net_port_loopback: bool = false;
    let net_port_tcp_tso: bool = false;
    let net_port_csum_offload: bool = false;

    let net_port_config = PortConfiguration {
                              name: net_port_name,
                              rx_queues: net_port_rx_queues,
                              tx_queues: net_port_tx_queues,
                              rxd: net_port_rxd,
                              txd: net_port_txd,
                              loopback: net_port_loopback,
                              tso: net_port_tcp_tso,
                              csum: net_port_csum_offload,
                          };

    // The set of ports used by netbricks.
    let net_ports: Vec<PortConfiguration> = vec![net_port_config];

    NetbricksConfiguration {
        name: net_config_name,
        secondary: dpdk_secondary,
        primary_core: net_primary_core,
        cores: net_cores,
        strict: net_strict_cores,
        ports: net_ports,
        pool_size: net_pool_size,
        cache_size: net_cache_size,
        dpdk_args: net_dpdk_args,
    }
}

/// This function configures and initializes Netbricks. In the case of a
/// failure, it causes the program to exit.
///
/// Returns a Netbricks context which can be used to setup and start the
/// server/client.
fn config_and_init_netbricks() -> NetbricksContext {
    let net_config: NetbricksConfiguration = get_default_netbricks_config();

    // Initialize Netbricks and return a handle.
    match e2d2::scheduler::initialize_system(&net_config) {
        Ok(net_context) => {
            return net_context;
        }

        Err(ref err) => {
            println!("Error during Netbricks init: {}", err);
            // TODO: Drop NetbricksConfiguration?
            std::process::exit(1);
        }
    }
}

fn main() {
    // Setup Netbricks.
    let mut net_context: NetbricksContext = config_and_init_netbricks();

    // Setup the client pipeline.
    net_context.start_schedulers();
    net_context.add_pipeline_to_run(Arc::new(
            move | ports, scheduler: &mut StandaloneScheduler |
            setup_client(ports, scheduler)
            ));

    // Run the client.
    net_context.execute();

    loop {
        ;
    }

    // Stop the client.
    net_context.stop();
}
